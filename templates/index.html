<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>API Computer Vision</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <script>
        window.MathJax = {
        tex: { inlineMath: [["$", "$"], ["\\(", "\\)"]] },
        svg: { fontCache: "global" }
        };
    </script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>

<div class="tabs">
    <button class="tab-button active" onclick="showTab('tab-1-cai-thien')">1. C·∫£i thi·ªán H√¨nh ·∫£nh (ƒêi·ªÉm & Hist)</button>
    <button class="tab-button" onclick="showTab('tab-2-loc-tan-so')">2. L·ªçc (Mi·ªÅn T·∫ßn s·ªë)</button>
    <button class="tab-button" onclick="showTab('tab-3-nang-cao')">3. X·ª≠ l√Ω N√¢ng cao & Ph·ª•c h·ªìi</button>
    <button class="tab-button" onclick="showTab('tab-4-phan-doan')">4. Ph√¢n ƒëo·∫°n ·∫£nh</button>
    </div>

<div class="container">
    
    <div id="tab-1-cai-thien" class="tab-content active">
        <aside class="technique-list">
            <h3>X·ª≠ l√Ω ƒêi·ªÉm</h3>
            <button onclick="showTechnique('negative_image')">1. Bi·∫øn ƒë·ªïi √Çm b·∫£n</button>
            <button onclick="showTechnique('log_transform')">2. Bi·∫øn ƒë·ªïi Logarit</button>
            <button onclick="showTechnique('power_law_transform')">3. Bi·∫øn ƒë·ªïi Lu·∫≠t C√¥ng su·∫•t (Gamma)</button>
            <h3>X·ª≠ l√Ω Histogram</h3>
            <button onclick="showTechnique('histogram_equalization')">4. C√¢n b·∫±ng Histogram</button>
            <h3>L·ªçc mi·ªÅn kh√¥ng gian</h3>
            <button onclick="showTechnique('spatial_filter')">5. L·ªçc mi·ªÅn kh√¥ng gian v·ªõi 3 ph∆∞∆°ng ph√°p</button>
        </aside>

        <main id="detail-area-1" class="main-content">
            <h2 id="technique-title">Ch·ªçn m·ªôt th·ªß thu·∫≠t t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ xem chi ti·∫øt v√† m√¥ ph·ªèng.</h2>
            <hr>
            <div id="knowledge-content-container"></div> 
        </main>
    </div>

    <div id="tab-2-loc-tan-so" class="tab-content">
        <aside class="technique-list">
            <h3>B·ªô l·ªçc Th√¥ng th·∫•p (Smoothing)</h3>
            <button onclick="showTechnique('gaussian_lowpass_filter')">1. Gaussian (GLPF)</button>
            <button onclick="showTechnique('ideal_lowpass_filter')">2. L√Ω t∆∞·ªüng (ILPF)</button>
            <button onclick="showTechnique('butterworth_lowpass_filter')">3. Butterworth (BLPF)</button>
            
            <h3>B·ªô l·ªçc Th√¥ng cao (Sharpening)</h3>
            <button onclick="showTechnique('gaussian_highpass_filter')">4. Gaussian (GHPF)</button>
            <button onclick="showTechnique('ideal_highpass_filter')">5. L√Ω t∆∞·ªüng (IHPF)</button>
            <button onclick="showTechnique('butterworth_highpass_filter')">6. Butterworth (BHPF)</button>
        </aside>

        <main id="detail-area-2" class="main-content">
            <h2 id="technique-title">Ch·ªçn m·ªôt th·ªß thu·∫≠t t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ xem chi ti·∫øt v√† m√¥ ph·ªèng.</h2>
            <hr>
            <div id="knowledge-content-container"></div> 
        </main>
    </div>

    <div id="tab-3-nang-cao" class="tab-content">
        <aside class="technique-list">
            <button onclick="showTechnique('contra_harmonic_mean')">1. B·ªô l·ªçc Ngh·ªãch ƒëi·ªÅu ho√†</button>
            <button onclick="showTechnique('adaptive_local_filter')">2. B·ªô l·ªçc Gi·∫£m nhi·ªÖu Th√≠ch nghi</button>
            <button onclick="showTechnique('inverse_filter')">3. B·ªô l·ªçc Ngh·ªãch ƒë·∫£o</button>

        </aside>
        
        <main id="detail-area-3" class="main-content"> 
            <h2 id="technique-title">Ch·ªçn m·ªôt th·ªß thu·∫≠t t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ xem chi ti·∫øt v√† m√¥ ph·ªèng.</h2>
            <hr>
        </main>
    </div>

    <div id="tab-4-phan-doan" class="tab-content">
        <aside class="technique-list">
            <button onclick="showTechnique('otsu_segmentation')">1. Ng∆∞·ª°ng ho√° Otsu</button>
            <button onclick="showTechnique('ml_segmentation')">2. S·ª≠ d·ª•ng m√¥ h√¨nh h·ªçc m√°y</button>
        </aside>
        
        <main id="detail-area-4" class="main-content"> 
            <h2 id="technique-title">Ch·ªçn m·ªôt th·ªß thu·∫≠t t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ xem chi ti·∫øt v√† m√¥ ph·ªèng.</h2>
            <hr>
        </main>
    </div>

</div>

<script>
    // C·∫•u h√¨nh tham s·ªë cho m·ªói th·ªß thu·∫≠t (D√πng ƒë·ªÉ t·∫°o Form Input ƒë·ªông)
    const SPATIAL_FILTER_OPTIONS = [
        { text: "L·ªçc Trung b√¨nh (Smoothing)", value: "mean", knowledge_key: "mean_filter" },
        { text: "L·ªçc Trung v·ªã (Median)", value: "median", knowledge_key: "median_filter" },
        { text: "L√†m s·∫Øc n√©t (Laplacian)", value: "laplacian_sharpen", knowledge_key: "laplacian_sharpen" }
    ];
    
    const techniqueConfig = {
        'negative_image': { name: "Bi·∫øn ƒë·ªïi √Çm b·∫£n", endpoint: "/api/process/negative_image", params: [] },
        'log_transform': { name: "Bi·∫øn ƒë·ªïi Logarit", endpoint: "/api/process/log_transform", 
            params: [{ name: "H·∫±ng s·ªë c", key: "c", type: "number", default: 1.0, step: 0.1 }] 
        },
        'power_law_transform': { name: "Bi·∫øn ƒë·ªïi Lu·∫≠t C√¥ng su·∫•t", endpoint: "/api/process/power_law_transform", 
            params: [
                { name: "H·∫±ng s·ªë c", key: "c", type: "number", default: 1.0, step: 0.1 },
                { name: "Gamma (Œ≥)", key: "gamma", type: "number", default: 0.6, step: 0.1 }
            ] 
        },
        'histogram_equalization': { name: "C√¢n b·∫±ng Histogram", endpoint: "/api/process/histogram_equalization", params: [] },
        // L·ªçc T·∫ßn s·ªë
        
        'spatial_filter': { 
            name: "L·ªçc mi·ªÅn kh√¥ng gian", 
            endpoint: "/api/process/spatial_filter",
            params: [
                { 
                    name: "Ki·ªÉu l·ªçc", 
                    key: "filter_type",
                    type: "select", 
                    default: "mean", 
                    options: SPATIAL_FILTER_OPTIONS // S·ª≠ d·ª•ng danh s√°ch options m·ªõi
                },
                { name: "K√≠ch th∆∞·ªõc Kernel", key: "kernel_size", type: "number", default: 3, step: 2 }
            ],
            knowledge_keys: { // Kh√≥a ki·∫øn th·ª©c c·∫ßn d√πng cho th·ªß thu·∫≠t n√†y
                mean: "mean_filter",
                median: "median_filter",
                laplacian_sharpen: "laplacian_sharpen"
            }
        },
        'gaussian_lowpass_filter': { name: "GLPF", endpoint: "/api/process/gaussian_lowpass_filter", 
            is_frequency_domain: true,
            params: [{ name: "T·∫ßn s·ªë c·∫Øt (D0)", key: "D0", type: "number", default: 50, step: 1 }] 
        },
        'gaussian_highpass_filter': { name: "GHPF", endpoint: "/api/process/gaussian_highpass_filter",
            is_frequency_domain: true, 
            params: [{ name: "T·∫ßn s·ªë c·∫Øt (D0)", key: "D0", type: "number", default: 50, step: 1 }] 
        },
        'ideal_highpass_filter': { name: "IHPF", endpoint: "/api/process/ideal_highpass_filter", 
            is_frequency_domain: true,
            params: [{ name: "T·∫ßn s·ªë c·∫Øt (D0)", key: "D0", type: "number", default: 50, step: 1 }] 
        },
        'ideal_lowpass_filter': { name: "ILPF", endpoint: "/api/process/ideal_lowpass_filter", 
            is_frequency_domain: true,
            params: [{ name: "T·∫ßn s·ªë c·∫Øt (D0)", key: "D0", type: "number", default: 50, step: 1 }] 
        },
        'butterworth_highpass_filter': { name: "BHPF", endpoint: "/api/process/butterworth_highpass_filter", 
            is_frequency_domain: true,
            params: [{ name: "T·∫ßn s·ªë c·∫Øt (D0)", key: "D0", type: "number", default: 50, step: 1 }] 
        },
        'butterworth_lowpass_filter': { name: "GHPF", endpoint: "/api/process/butterworth_lowpass_filter", 
            is_frequency_domain: true,
            params: [{ name: "T·∫ßn s·ªë c·∫Øt (D0)", key: "D0", type: "number", default: 50, step: 1 }] 
        },
        'contra_harmonic_mean': { 
            name: "B·ªô l·ªçc Trung b√¨nh Ngh·ªãch ƒëi·ªÅu h√≤a", 
            endpoint: "/api/process/contra_harmonic_mean",
            params: [
                { name: "K√≠ch th∆∞·ªõc Kernel", key: "kernel_size", type: "number", default: 3, step: 2 },
                { 
                    name: "B·∫≠c Q", key: "Q", type: "number", default: 1.5, step: 0.1,
                    note: "Q > 0 lo·∫°i b·ªè nhi·ªÖu ti√™u, Q < 0 lo·∫°i b·ªè nhi·ªÖu mu·ªëi"
                }
            ],
            // V√¨ ƒë√¢y l√† th·ªß thu·∫≠t ƒë∆°n l·∫ª, knowledge key s·∫Ω l√† ch√≠nh n√≥
            knowledge_keys: { default: "contra_harmonic_mean" } 
        },
        'adaptive_local_filter': {
            name: "B·ªô l·ªçc gi·∫£m nhi·ªÖu c·ª•c b·ªô th√≠ch nghi",
            endpoint: "/api/process/adaptive_local_filter",
            params: [
                {
                    name: "K√≠ch th∆∞·ªõc Kernel", key: "kernel_size", type: "number", default: 3, step: 2
                    },
                {name: "To·∫° ƒë·ªô X c·ªßa v√πng", key: "x_start", type: "number", default: 0, step: 1},
                {name: "To·∫° ƒë·ªô Y c·ªßa v√πng", key: "y_start", type: "number", default: 0, step: 1},
                {name: "Chi·ªÅu r·ªông v√πng", key: "width", type: "number", default: 10, step: 1},
                {name: "Chi·ªÅu d√†i v√πng", key: "height", type: "number", default: 10, step: 1}

            ]
        },
        'inverse_filter': {
            name: "B·ªô l·ªçc ƒë·∫£o ng∆∞·ª£c",
            endpoint: "/api/process/inverse_filter",
            is_frequency_domain: true,
            params: [
                {
                    name: "Tham s·ªë c∆∞·ªùng ƒë·ªô suy gi·∫£m", key: "modelK", type: "number", default: 0.0025, step: 0.0001
                },
                {
                    name: "Gi·ªõi h·∫°n t·∫ßn s·ªë", key: "cutoff_ratio", type: "number", default: 0.7, step: 0.01
                }
            ]
        },
        'otsu_segmentation': {
            name: "Ng∆∞·ª°ng h√≥a Otsu (Otsu Thresholding)",
            endpoint: "/api/process/otsu_segmentation",
            params: [],
            knowledge_key_name: "otsu_segmentation"
        },
        'ml_segmentation': {
            name: "Ph√¢n v√πng d√πng Machine Learning",
            endpoint: "/api/process/ml_segmentation",
            params: [
                {
                    name: "Ch·ªçn Thu·∫≠t to√°n", 
                    key: "model_type",
                    type: "select", 
                    default: "kmeans", 
                    options: [
                        // Khai th√°c Clustering Model cho Segmentation
                        { text: "K-Means Clustering", value: "kmeans", knowledge_key: "kmeans_segmentation" },
                        { text: "Mean Shift Clustering", value: "mean_shift", knowledge_key: "mean_shift_segmentation" }
                    ],
                    is_knowledge_switcher: true
                },
                // Tham s·ªë chung cho c·∫£ hai m√¥ h√¨nh (ch·ªß y·∫øu cho K-Means)
                { name: "S·ªë l∆∞·ª£ng Nh√≥m (K)", key: "n_clusters", type: "number", default: 3, step: 1 },
                { name: "Bandwidth (Mean Shift)", key: "bandwidth", type: "number", default: 0, step: 0.1 }
            ],
            // D√πng kh√≥a ki·∫øn th·ª©c r·∫Ω nh√°nh v√¨ c√≥ dropdown
            knowledge_keys: {
                kmeans: "kmeans_segmentation",
                mean_shift: "mean_shift_segmentation",
                default: "kmeans_segmentation"
            }
        }
        // Th√™m c√°c th·ªß thu·∫≠t c√≤n l·∫°i...
    };

    function showTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));
        document.querySelector(`.tabs button[onclick="showTab('${tabId}')"]`).classList.add('active');
    }

    // H√†m Ch√≠nh ƒë·ªÉ t·∫£i v√† hi·ªÉn th·ªã ki·∫øn th·ª©c
    function getKnowledgeKey(config, selectedFilterType) {
        // 1. N·∫øu ƒë√¢y l√† th·ªß thu·∫≠t c√≥ dropdown (spatial_filter)
        if (config.knowledge_keys) {
            return config.knowledge_keys[selectedFilterType];
        }
        // 2. N·∫øu l√† th·ªß thu·∫≠t ƒë∆°n l·∫ª (log_transform, negative_image, etc.)
        return config.techKey; // Tr·∫£ v·ªÅ ch√≠nh techKey (vd: 'negative_image')
    }

    async function showTechnique(techKey) {
        const config = techniqueConfig[techKey];
        const activeTabId = document.querySelector('.tab-content.active').id;
        const detailArea = document.getElementById(`detail-area-${activeTabId.split('-')[1]}`);

        if (!config) {
            detailArea.innerHTML = `<h2>Th·ªß thu·∫≠t ${techKey} ch∆∞a ƒë∆∞·ª£c tri·ªÉn khai.</h2>`;
            return;
        }

        // 1. T·∫¢I V√Ä HI·ªÇN TH·ªä KI·∫æN TH·ª®C M·∫∂C ƒê·ªäNH
        let filterTypeParam = config.params.find(p => p.key === 'filter_type');
        let initialKnowledgeKey = techKey; 
        
        if (filterTypeParam) {
            const defaultFilterType = filterTypeParam.default;
            initialKnowledgeKey = config.knowledge_keys[defaultFilterType];
        } else if (config.knowledge_keys && config.knowledge_keys.default) {
             // D√πng cho th·ªß thu·∫≠t ƒë∆°n l·∫ª c√≥ key default (v√≠ d·ª•: contra_harmonic_mean)
             initialKnowledgeKey = config.knowledge_keys.default;
        }
        
        const knowledgeResponse = await fetch(`/api/knowledge/${initialKnowledgeKey}`);
        const knowledge = await knowledgeResponse.json();

        // 2. T·∫†O TO√ÄN B·ªò GIAO DI·ªÜN M·ªöI
        // T√åM ID C·ª¶A KHU V·ª∞C CHI TI·∫æT ƒêANG HO·∫†T ƒê·ªòNG
        
        const isFrequencyFilter = config.is_frequency_domain;

        // Logic t·∫°o HTML cho Chart T·∫ßn s·ªë (ch·ªâ t·∫°o n·∫øu l√† Tab 2)
        const frequencyChartHTML = isFrequencyFilter ? `
            <h4>Bi·ªÉu ƒë·ªì Mi·ªÅn T·∫ßn s·ªë:</h4>
            <div class="frequency-chart-display">
                <div class="col"> <img id="spectrum-original-${techKey}" src="" alt="Ph·ªï G·ªëc" style="display:none;"> <p>Ph·ªï T·∫ßn s·ªë G·ªëc |F(u,v)|</p> </div>
                <div class="col"> <img id="filter-mask-${techKey}" src="" alt="Mask H(u,v)" style="display:none;"> <p>H√†m truy·ªÅn B·ªô l·ªçc H(u,v)</p> </div>
                <div class="col"> <img id="spectrum-filtered-${techKey}" src="" alt="Ph·ªï ƒê√£ L·ªçc" style="display:none;"> <p>Ph·ªï T·∫ßn s·ªë ƒê√£ L·ªçc |G(u,v)|</p> </div>
            </div>
        ` : '';
        
        // G√°n to√†n b·ªô HTML v√†o detailArea
        detailArea.innerHTML = `
            <h2 id="technique-title">${config.name}</h2>
            <hr>

            <div class="knowledge-section" id="knowledge-content-${techKey}">
                <h3>üìñ Ki·∫øn th·ª©c c∆° b·∫£n v·ªÅ ${knowledge.name}</h3>
                <p>${knowledge.description}</p>
                <p><strong>C√¥ng th·ª©c:</strong> <span class="latex">${knowledge.formula}</span></p> 
                <p><strong>M·ª•c ƒë√≠ch:</strong> ${knowledge.purpose}</p>
            </div>
            
            <hr>

            <div class="simulation-section">
                <h3>‚öôÔ∏è M√¥ ph·ªèng v√† Th·ª≠ nghi·ªám</h3>
                <form id="simulation-form-${techKey}" action="${config.endpoint}" method="POST" enctype="multipart/form-data">
                    <label for="image_file">Ch·ªçn ·∫¢nh ƒê·∫ßu V√†o:</label>
                    <input type="file" name="image_file" required><br><br>
                    
                    ${renderParamsHTML(config)} 
                    <button type="submit" style="margin-top: 10px;">√Åp d·ª•ng Th·ªß thu·∫≠t</button>
                </form>
            </div>

            <div class="results">
                <h4>·∫¢nh Before & After:</h4>
                <div class="image-display">
                    <div class="col"> <img id="img-before-${techKey}" src="" alt="·∫¢nh G·ªëc" style="display:none;"> <p>·∫¢nh G·ªëc</p> </div>
                    <div class="col"> 
                        <img id="img-after-${techKey}" src="" alt="·∫¢nh ƒê√£ X·ª≠ L√Ω" style="display:none;"> <p>·∫¢nh ƒê√£ L·ªçc</p> 
                        <button 
                            type="button" 
                            onclick="downloadImage('img-after-${techKey}', 'processed_${techKey}.png')"
                            style="margin-top: 5px; padding: 5px 10px; background-color: #27ae60; color: white; border: none; cursor: pointer; border-radius: 3px;"
                        >
                            ‚¨áÔ∏è T·∫£i ·∫£nh n√†y v·ªÅ
                        </button>
                    </div>
                </div>
                ${frequencyChartHTML}
            </div>
        `;
        MathJax.typeset();

        
        // 3. G·∫ÆN S·ª∞ KI·ªÜN (Sau khi HTML ƒë√£ ƒë∆∞·ª£c ch√®n)
        
        // G·∫Øn s·ª± ki·ªán Change cho Dropdown (n·∫øu t·ªìn t·∫°i)
        const filterSelect = detailArea.querySelector('select[name="filter_type"]');
        if (filterSelect) {
            filterSelect.addEventListener('change', async (event) => {
                const selectedType = event.target.value;
                const knowledgeKey = config.knowledge_keys[selectedType];
                await updateKnowledgeDisplay(techKey, knowledgeKey);
            });
        }

        const modelSelect = detailArea.querySelector('select[name="model_type"]'); 
    
        if (modelSelect) {
            // T√åM C·∫§U H√åNH THAM S·ªê C·ª¶A DROPDOWN N√ÄY
            const modelParamConfig = config.params.find(p => p.key === 'model_type'); 
            
            modelSelect.addEventListener('change', async (event) => {
                const selectedType = event.target.value;
                // T√¨m kh√≥a ki·∫øn th·ª©c (knowledgeKey) d·ª±a tr√™n gi√° tr·ªã ƒë√£ ch·ªçn
                const option = modelParamConfig.options.find(opt => opt.value === selectedType);
                const knowledgeKey = option ? option.knowledge_key : null;
                
                if (knowledgeKey) {
                    // T·∫£i v√† c·∫≠p nh·∫≠t n·ªôi dung ki·∫øn th·ª©c
                    await updateKnowledgeDisplay(techKey, knowledgeKey); 
                }
            });
        }

        // G·∫Øn s·ª± ki·ªán submit cho Form
        document.getElementById(`simulation-form-${techKey}`).addEventListener('submit', (event) => handleFormSubmit(event, techKey));
    }

    // H√†m updateKnowledgeDisplay c·∫ßn s·ª≠a ƒë·ªÉ nh·∫≠n knowledgeKey TR·ª∞C TI·∫æP
    async function updateKnowledgeDisplay(techKey, knowledgeKey) {
        const knowledgeSection = document.getElementById(`knowledge-content-${techKey}`); 
        if (!knowledgeSection) return; 

        // 1. T·∫£i KI·∫æN TH·ª®C
        const knowledgeResponse = await fetch(`/api/knowledge/${knowledgeKey}`);
        
        if (knowledgeResponse.ok) {
            const knowledge = await knowledgeResponse.json();
            
            // 2. C·∫≠p nh·∫≠t n·ªôi dung HTML
            knowledgeSection.innerHTML = `
                <h3>üìñ Ki·∫øn th·ª©c c∆° b·∫£n v·ªÅ ${knowledge.name}</h3>
                <p>${knowledge.description}</p>
                <p><strong>C√¥ng th·ª©c:</strong> <span class="latex">${knowledge.formula}</span></p> 
                <p><strong>M·ª•c ƒë√≠ch:</strong> ${knowledge.purpose}</p>
            `;

            // 3. [QUAN TR·ªåNG] K√çCH HO·∫†T L·∫†I MATHJAX CHO KHU V·ª∞C M·ªöI
            // Ki·ªÉm tra xem MathJax ƒë√£ t·∫£i ch∆∞a tr∆∞·ªõc khi g·ªçi
            if (window.MathJax) {
                MathJax.typesetPromise([knowledgeSection]).then(() => {
                    console.log("MathJax updated!");
                }).catch((err) => console.log("MathJax error:", err));
            }

        } else {
            knowledgeSection.innerHTML = "<p>L·ªói t·∫£i ki·∫øn th·ª©c.</p>";
        }
    }

    // T√°ch logic t·∫°o params ra kh·ªèi h√†m showTechnique ƒë·ªÉ l√†m s·∫°ch code
    function renderParamsHTML(config) {
        // Logic c·ªßa b·∫°n ƒë·ªÉ t·∫°o paramsHTML (Select ho·∫∑c Input) n√™n n·∫±m ·ªü ƒë√¢y
        return config.params.map(p => {
            if (p.type === 'select') {
                const optionsHTML = p.options.map(opt => 
                    `<option value="${opt.value}" ${opt.value === p.default ? 'selected' : ''}>${opt.text}</option>`
                ).join('');
                return `
                    <div>
                        <label for="${p.key}">${p.name}:</label>
                        <select name="${p.key}">
                            ${optionsHTML}
                        </select>
                    </div>
                `;
            } else {
                return `
                    <div>
                        <label for="${p.key}">${p.name}:</label>
                        <input type="${p.type}" name="${p.key}" value="${p.default}" step="${p.step}">
                    </div>
                `;
            }
        }).join('');
    }
    function downloadImage(imgId, fileName) {
        const img = document.getElementById(imgId);
        
        // Ki·ªÉm tra xem c√≥ ·∫£nh kh√¥ng
        if (!img || !img.src || img.src === window.location.href || img.style.display === 'none') {
            alert("Ch∆∞a c√≥ ·∫£nh k·∫øt qu·∫£ ƒë·ªÉ t·∫£i v·ªÅ!");
            return;
        }

        // T·∫°o th·∫ª <a> ·∫£o ƒë·ªÉ k√≠ch ho·∫°t t·∫£i v·ªÅ
        const link = document.createElement('a');
        link.href = img.src; // L·∫•y ngu·ªìn ·∫£nh hi·ªán t·∫°i (Base64 string)
        link.download = fileName; // T√™n file khi t·∫£i v·ªÅ
        
        // K√≠ch ho·∫°t click v√† d·ªçn d·∫πp
        document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
    async function handleFormSubmit(event, techKey) {
        event.preventDefault(); // NgƒÉn ch·∫∑n form submit truy·ªÅn th·ªëng
        const form = event.target;
        const formData = new FormData(form);
        const config = techniqueConfig[techKey];
        
        // 1. Hi·ªÉn th·ªã ·∫£nh g·ªëc (N·∫øu c√≥ file ƒë∆∞·ª£c ch·ªçn)
        const fileInput = formData.get('image_file');
        const imgBefore = document.getElementById(`img-before-${techKey}`);
        const imgAfter = document.getElementById(`img-after-${techKey}`);

        if (fileInput && fileInput.size > 0) {
            const originalFormData = new FormData();
            originalFormData.append('image_file', fileInput);
            
            // G·ªçi API ƒë·ªÉ chuy·ªÉn file g·ªëc sang PNG
            const originalResponse = await fetch('/api/convert/to_png', {
                method: 'POST',
                body: originalFormData
            });
            
            if (originalResponse.ok) {
                const originalBlob = await originalResponse.blob();
                imgBefore.src = URL.createObjectURL(originalBlob);
                imgBefore.style.display = 'block';
                
                // --- K√çCH HO·∫†T T√çNH NƒÇNG CH·ªåN V√ôNG ---
                // ƒê·ª£i ·∫£nh load xong m·ªõi t√≠nh to√°n k√≠ch th∆∞·ªõc ƒë∆∞·ª£c
                imgBefore.onload = () => {
                    initImageSelection(`img-before-${techKey}`);
                };
                
                imgAfter.style.display = 'none'; 
            } else {
                // X·ª≠ l√Ω l·ªói n·∫øu kh√¥ng th·ªÉ hi·ªÉn th·ªã ·∫£nh g·ªëc
                imgBefore.alt = "L·ªói: Kh√¥ng th·ªÉ hi·ªÉn th·ªã ·∫£nh g·ªëc (.tif)";
                imgBefore.style.display = 'block';
                imgAfter.style.display = 'none';
                return; 
            }
        } else {
            alert("Vui l√≤ng ch·ªçn m·ªôt file ·∫£nh.");
            return;
        }

        // 2. G·ª≠i POST Request ƒë·∫øn API
        try {
            const response = await fetch(config.endpoint, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                // NH·∫¨N JSON CH·ª®A T·∫§T C·∫¢ D·ªÆ LI·ªÜU (Ch·ª©a √≠t nh·∫•t 'filtered_image')
                const results = await response.json();
                
                // H√†m hi·ªÉn th·ªã Base64 (s·ª≠ d·ª•ng l·∫°i logic n√†y)
                const displayBase64 = (id, base64String) => {
                    const el = document.getElementById(id);
                    if (el && base64String) { // Th√™m ki·ªÉm tra base64String c√≥ t·ªìn t·∫°i kh√¥ng
                        el.src = 'data:image/png;base64,' + base64String;
                        el.style.display = 'block';
                    } else if (el) {
                        el.style.display = 'none'; // ·∫®n n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
                    }
                };

                // HI·ªÇN TH·ªä C√ÅC TH√ÄNH PH·∫¶N CHUNG: ·∫¢nh ƒê√£ L·ªçc
                displayBase64(`img-after-${techKey}`, results.filtered_image);
                
                // HI·ªÇN TH·ªä C√ÅC TH√ÄNH PH·∫¶N CHART (Ch·ªâ t·ªìn t·∫°i ·ªü Tab 2)
                // N·∫øu c√°c kh√≥a n√†y kh√¥ng t·ªìn t·∫°i trong JSON (nh∆∞ ·ªü Tab 1), ch√∫ng s·∫Ω b·ªã b·ªè qua/·∫©n
                displayBase64(`spectrum-original-${techKey}`, results.original_spectrum);
                displayBase64(`spectrum-filtered-${techKey}`, results.filtered_spectrum);
                displayBase64(`filter-mask-${techKey}`, results.filter_mask);
            } else {
                const errorData = await response.json();
                alert(`L·ªói API (${response.status}): ${errorData.error}`);
            }
        } catch (error) {
            alert("ƒê√£ x·∫£y ra l·ªói k·∫øt n·ªëi ho·∫∑c x·ª≠ l√Ω m·∫°ng.");
            console.error(error);
        }
    }
    let isDragging = false;
    let startX, startY;
    let selectionBox = null;
    let pixelInfoBox = null;
    let currentImgElement = null;

    // H√†m kh·ªüi t·∫°o t√≠nh nƒÉng ch·ªçn v√πng cho m·ªôt ·∫£nh c·ª• th·ªÉ
    function initImageSelection(imgId) {
        const img = document.getElementById(imgId);
        if (!img) return;
        
        // B·ªçc ·∫£nh v√†o container n·∫øu ch∆∞a c√≥
        if (!img.parentElement.classList.contains('img-container')) {
            const container = document.createElement('div');
            container.className = 'img-container';
            img.parentNode.insertBefore(container, img);
            container.appendChild(img);
            
            // T·∫°o h·ªôp ch·ªçn (Selection Box)
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            container.appendChild(selectionBox);

            // T·∫°o h·ªôp th√¥ng tin pixel (Tooltip)
            pixelInfoBox = document.createElement('div');
            pixelInfoBox.className = 'pixel-info';
            container.appendChild(pixelInfoBox);
        } else {
            // N·∫øu ƒë√£ c√≥ container, l·∫•y l·∫°i tham chi·∫øu
            selectionBox = img.parentElement.querySelector('.selection-box');
            pixelInfoBox = img.parentElement.querySelector('.pixel-info');
        }
        
        currentImgElement = img;

        // --- G·∫ÆN S·ª∞ KI·ªÜN CHU·ªòT ---

        // 1. Hi·ªÉn th·ªã T·ªça ƒë·ªô (Hover)
        img.addEventListener('mousemove', (e) => {
            const rect = img.getBoundingClientRect();
            // T√≠nh t·ªça ƒë·ªô th·ª±c t·∫ø tr√™n ·∫£nh (scale theo k√≠ch th∆∞·ªõc hi·ªÉn th·ªã)
            const scaleX = img.naturalWidth / img.width;
            const scaleY = img.naturalHeight / img.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            
            // C·∫≠p nh·∫≠t tooltip
            pixelInfoBox.style.display = 'block';
            pixelInfoBox.style.left = (e.clientX - rect.left + 10) + 'px';
            pixelInfoBox.style.top = (e.clientY - rect.top + 10) + 'px';
            pixelInfoBox.innerText = `X: ${x}, Y: ${y}`; // C√≥ th·ªÉ th√™m RGB n·∫øu v·∫Ω l√™n canvas
            
            // X·ª≠ l√Ω k√©o chu·ªôt (Dragging)
            if (isDragging) {
                updateSelectionBox(e, rect);
            }
        });

        img.addEventListener('mouseout', () => {
            pixelInfoBox.style.display = 'none';
        });

        // 2. B·∫Øt ƒë·∫ßu ch·ªçn (MouseDown)
        img.addEventListener('mousedown', (e) => {
            e.preventDefault(); // NgƒÉn k√©o ·∫£nh m·∫∑c ƒë·ªãnh
            isDragging = true;
            const rect = img.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            
            // Reset h·ªôp ch·ªçn
            selectionBox.style.display = 'block';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
        });

        // 3. K·∫øt th√∫c ch·ªçn (MouseUp)
        window.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                finalizeSelection(img);
            }
        });
    }

    function updateSelectionBox(e, rect) {
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        const left = Math.min(currentX, startX);
        const top = Math.min(currentY, startY);
        
        selectionBox.style.width = width + 'px';
        selectionBox.style.height = height + 'px';
        selectionBox.style.left = left + 'px';
        selectionBox.style.top = top + 'px';
    }

    function finalizeSelection(img) {
        // T√≠nh to√°n t·ªça ƒë·ªô th·ª±c t·∫ø (Natural dimensions) ƒë·ªÉ ƒëi·ªÅn v√†o form
        const rect = img.getBoundingClientRect();
        
        // L·∫•y k√≠ch th∆∞·ªõc t·ª´ style c·ªßa selectionBox (pixel hi·ªÉn th·ªã)
        const displayedLeft = parseFloat(selectionBox.style.left);
        const displayedTop = parseFloat(selectionBox.style.top);
        const displayedWidth = parseFloat(selectionBox.style.width);
        const displayedHeight = parseFloat(selectionBox.style.height);
        
        // T·ªâ l·ªá scale
        const scaleX = img.naturalWidth / img.width;
        const scaleY = img.naturalHeight / img.height;
        
        // Chuy·ªÉn ƒë·ªïi sang t·ªça ƒë·ªô ·∫£nh g·ªëc
        const realX = Math.round(displayedLeft * scaleX);
        const realY = Math.round(displayedTop * scaleY);
        const realW = Math.round(displayedWidth * scaleX);
        const realH = Math.round(displayedHeight * scaleY);
        
        console.log(`V√πng ch·ªçn: X=${realX}, Y=${realY}, W=${realW}, H=${realH}`);
        
        // T·ª± ƒë·ªông ƒëi·ªÅn v√†o Form (N·∫øu c√°c input t·ªìn t·∫°i)
        fillInput('x_start', realX);
        fillInput('y_start', realY);
        fillInput('width', realW);
        fillInput('height', realH);
    }

    function fillInput(name, value) {
        const input = document.querySelector(`input[name="${name}"]`);
        if (input) {
            input.value = value;
            // T·∫°o hi·ªáu ·ª©ng nh·∫•p nh√°y ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt ƒë√£ ƒëi·ªÅn
            input.style.backgroundColor = '#e8f0fe';
            setTimeout(() => input.style.backgroundColor = '', 500);
        }
    }
    // Kh·ªüi t·∫°o tab ƒë·∫ßu ti√™n khi t·∫£i trang
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelector('.tab-button').click(); 
    });
</script>

</body>
</html>